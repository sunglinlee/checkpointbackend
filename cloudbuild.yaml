steps:
  # 步驟 1: 取得這次提交中所有變動的檔案列表
  # 這個步驟會比較 HEAD 和 HEAD^ 之間的差異，並將所有變動檔案的路徑輸出到一個檔案中，以便後續步驟讀取。
  # 由於 Cloud Build 的每個步驟都可以在同一個工作區 (`/workspace`) 中讀寫檔案，
  # 這是解決自定義變數問題的最佳方式。
  - name: 'gcr.io/cloud-builders/git'
    id: 'get-changed-files'
    entrypoint: 'bash'
    args: ['-c', 'git diff HEAD^ HEAD --name-only > /workspace/changed_files.txt']

  # 步驟 2: 條件式地建置與部署
  # 這個步驟會讀取上一個步驟寫入的變動檔案列表，並判斷您的後端目錄是否有變動。
  # 如果有，則執行 Docker 建置、推送和 Cloud Run 部署的流程。
  # 我們直接在腳本中執行 docker 和 gcloud 命令，而不是透過外部參數傳遞變數。
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'conditional-build-and-deploy'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # 使用 cat 來讀取上一個步驟寫入的檔案
        CHANGED_FILES=$(cat /workspace/changed_files.txt)
        echo "Detected changed files: $CHANGED_FILES"
        
        # 請將 'YOUR_BACKEND_DIR/' 替換成您的後端程式碼實際所在的目錄名稱
        # 例如：如果您的後端程式碼在 repo 的 'backend/' 目錄下，請將此處改為 'backend/'
        # 重要的提示：確保 Dockerfile 位於此目錄中，或者調整 Docker build 命令以指向正確的 Dockerfile 路徑。
        if echo "$CHANGED_FILES" | grep -q 'YOUR_BACKEND_DIR/'; then
          echo "Changes detected in backend directory. Proceeding with build and deploy."
          
          # 執行 Docker 建置。`$_REGION` 等變數是內建的，可以直接使用。
          # 由於 Dockerfile 預設會在當前目錄下查找，請確保您的 Dockerfile 位於 'YOUR_BACKEND_DIR/' 內，
          # 並且在執行此步驟前，您已經將工作目錄切換到該目錄，或明確指定 Dockerfile 路徑。
          # 以下假設您的 Cloud Build 觸發器配置為在倉庫根目錄執行，且 Dockerfile 在 'YOUR_BACKEND_DIR/' 下。
          # 如果您的 Dockerfile 不在根目錄，您可能需要調整 `docker build` 命令的上下文或使用 `dir` 屬性。
          # 例如，如果 `YOUR_BACKEND_DIR/` 是 `backend/`，並且 Dockerfile 在 `backend/Dockerfile`，
          # 您可以考慮在 `docker build` 命令中添加 `--file=./backend/Dockerfile ./backend`。
          
          # 將以下 Docker build 命令的最後一個參數 (context path) 設為您的後端目錄。
          # 假設您的 Dockerfile 位於 YOUR_BACKEND_DIR/Dockerfile
          docker build -t ${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPOSITORY}/${_IMAGE_NAME}:$COMMIT_SHA ./YOUR_BACKEND_DIR/
          
          # 將建置好的映像檔推送到 Artifact Registry
          docker push ${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPOSITORY}/${_IMAGE_NAME}:$COMMIT_SHA
          
          # 將新映像檔部署到 Cloud Run
          gcloud run deploy ${_SERVICE_NAME} \
            --image=${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPOSITORY}/${_IMAGE_NAME}:$COMMIT_SHA \
            --region=${_REGION} \
            --platform=managed \
            --allow-unauthenticated
        else
          echo "No changes detected in backend directory. Skipping build and deploy."
        fi

# 這個設定讓 Cloud Build 能夠知道最終的映像檔是哪個，並能夠正確處理相關權限。
images:
  - '${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPOSITORY}/${_IMAGE_NAME}:$COMMIT_SHA'

# options 區塊來指定日誌記錄行為
options:
  logging: CLOUD_LOGGING_ONLY

# 定義替代變數
substitutions:
  _SERVICE_NAME: checkpoint-backend   # 替換成您的 Cloud Run 服務名稱
  _REGION: asia-east1                 # 替換成您的部署地區
  _REPOSITORY: checkpoint2cicd        # 替換成您的 Artifact Registry 存放區名稱
  _IMAGE_NAME: checkpoint-be          # 替換成您想要的映像檔名稱
